"""


Base Device Schema:
{
    "id": str,                # internal UUID (generated by our system)
    "name": str,              # human-readable name
    "manufacturer": str,      # e.g. "TP-Link", "eWeLink", "Shelly"
    "model": str | None,      # optional device model if known
    "type": str,              # e.g. "smart_switch", "light", "sensor"

    "identifiers": {          # manufacturer-specific identifiers
        "ip": str | None,
        "mac": str | None,
        "device_id": str | None,   # eWeLink ID, etc.
        "api_name": str | None     # whatever name API uses
    },

    "connection": {
        "protocol": str,           # e.g. "local_http", "mqtt_DEPRECATED", "cloud_api"
        "status": str | None,      # "online", "offline", etc.
    },

    "capabilities": [str],         # e.g. ["on_off", "brightness", "color"]
    "metadata": dict               # freeform storage for extra info
}
"""

# src/core/base_device.py

from abc import ABC, abstractmethod
from typing import Dict, Any


class BaseDevice(ABC):
    """
    A unified interface for any smart device (TP-Link, eWeLink, etc.)
    """

    def __init__(self, device_id: str, name: str, manufacturer: str, meta: Dict[str, Any]):
        self.device_id = device_id
        self.name = name
        self.manufacturer = manufacturer
        self.meta = meta or {}

    @abstractmethod
    async def turn_on(self):
        """Turn the device on"""
        pass

    @abstractmethod
    async def turn_off(self):
        """Turn the device off"""
        pass

    @abstractmethod
    async def toggle(self):
        """Toggle the device on/off"""
        pass

    @abstractmethod
    async def get_state(self) -> Dict[str, Any]:
        """Return the device state as a dictionary"""
        pass

    def __repr__(self):
        return f"<{self.manufacturer}:{self.name} ({self.device_id})>"



'''
#import asyncio
import uuid

from abc import ABC, abstractmethod
from typing import Any, Dict


class BaseDevice(ABC):
    def __init__(self, device_id: str, name: str, location: str, device_ip: str = None, device_mac: str = None):
        self.device_id = device_id
        self.device_ip = device_ip
        self.device_mac = device_mac
        self.name = name
        self.location = location
        self.state: Dict[str, Any] = {}

    @abstractmethod
    async def turn_on(self) -> bool:
        pass

    @abstractmethod
    async def turn_off(self) -> bool:
        pass
    
    @abstractmethod
    async def dim(self) -> bool:
        pass

    @abstractmethod
    async def get_state(self) -> Dict[str, Any]:
        pass

    async def toggle(self) -> bool:
        current = await self.get_state()
        if current.get("power") == "on":
            return await self.turn_off()
        else:
            return await self.turn_on()

'''


## Adaptors,
# NOTE: These are used as translators to have the normalized data for the device.
# [Vendor Adapter] → [Device Registry] → [BaseDevice Abstraction] → [System Logic]

